<!DOCTYPE html>
<html lang = "en">
	<head>
		<title>Tank Test</title>
		<link rel="icon" href="../../assets/images/icon.png">
		<link href='../../assets/css/header.css' rel='stylesheet'>
		<meta name="robots" content="noindex">
	</head>
	<body>
		
		<div class="content">
			<canvas id="canvas" height="300" width="300"></canvas>
			<br>
			<form action="" method="" id="menu">
                <fieldset>
                  <legend>Select Inputs</legend>
                  <button>Start</button>
                </fieldset>
              </form>
		</div>
	</body>

	<script>
        // have drop down for number of tanks, 2-max
        // have options to configure control methods
        // have option to configure map size
		// use setInterval(loop, 10); to loop game, and update pos of thanks based on boolean for keys pressed, start interval when game starts and end interval when game ends

		// Objects
		class Tank {
			constructor(xpos, ypos, forward, backward, left, right, shoot){
                // postion variables
                this.xpos = xpos;
                this.ypos = ypos;
                this.deg = 0;

                // control variables
                this.forward = forward;
                this.backward = backward;
                this.left = left;
                this.right = right;
                this.shoot = shoot;
                
                // state variables
                this.isForwardState = false;
                this.isBackwardState = false;
                this.isLeftState = false;
                this.isRightState = false;
                this.isShootState = false;
                this.isReloading = false;

                // tanks attributes
				this.width = 10;
				this.height = 15;
				this.vel = 3;
                this.shots = [];
	        }

			update_pos(){
                // Move Forward
				if(this.isForwardState){
					this.xpos += this.vel*Math.sin(this.deg* Math.PI/180);
					this.ypos -= this.vel*Math.cos(this.deg* Math.PI/180);
				}
                // Move Backward
				if (this.isBackwardState){
					this.xpos -= this.vel*Math.sin(this.deg* Math.PI/180);
					this.ypos += this.vel*Math.cos(this.deg* Math.PI/180);
				}
                // Turn Left
				if(this.isLeftState){
					this.deg-=this.vel;
				}
                // Turn Right
				if(this.isRightState){
					this.deg+=this.vel;
				}
                // Shoot
                if(this.isShootState && !this.isReloading && this.shots.length <3){
                    this.isReloading = true;
                    let hyp = Math.sqrt((this.width**2+this.height**2));
                    let shot_x_pos = this.xpos + this.width/2 + hyp*Math.sin(this.deg* Math.PI/180);
                    let shot_y_pos = this.ypos + this.height/2 - hyp*Math.cos(this.deg* Math.PI/180);
                    //myInterval = setInterval(this.removeshot(shots.length), 2000);
                    //clearInterval(myInterval);
					//or use set timeout
					this.shots.push(new Shot(shot_x_pos, shot_y_pos, this.deg));
				}

                // Reload
                else if(!this.isShootState && this.isReloading){
                    this.isReloading = false;
                }
                
                // Move Shots
                for(const shot in this.shots){
                    this.shots[shot].xpos += this.shots[shot].vel*Math.sin(this.shots[shot].deg* Math.PI/180);
					this.shots[shot].ypos -= this.shots[shot].vel*Math.cos(this.shots[shot].deg* Math.PI/180);
                }
			}
            
			//need to handle left & right, forward & backward being pressed at the same time
            check_buttons(button_pressed, event_type) {
				switch (button_pressed) {
					case this.forward:
						this.isForwardState = event_type;
						break;
					case this.backward:
						this.isBackwardState = event_type;
						break;
					case this.left:
						this.isLeftState = event_type;
						break;
					case this.right:
						this.isRightState = event_type;
						break;
					case this.shoot:
						this.isShootState = event_type;
						break;
					default:
				}
            }
		
        }

        class Shot {
			constructor(xpos, ypos, deg){
                this.xpos = xpos;
                this.ypos = ypos;
                this.deg = deg;
				this.rad = 1;
				this.vel = 6;
	        }

			update_pos(){
				this.xpos -= this.vel*Math.sin(this.deg* Math.PI/180);
				this.ypos += this.vel*Math.cos(this.deg* Math.PI/180);
			}
		}

        // variables
        let tanks = [];

		// setup
		start();
        
		// functions

        function create_tanks(num_of_tanks) {
            tanks = [];
            tanks[0] = new Tank(50, 50, 'w', 's', 'a', 'd', 'e');
            tanks[1] = new Tank(75, 75, 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ');
            /*
            for(let i = 0; i<num_of_tanks; i++){
                xpos = 50;
                ypos = 50;
                angle = 0;
                forward = 'w';
                backward = 's';
                left = 'a';
                right = 'd';
                shoot = 'e';
                tanks[i] = new tank(xpos, ypos, forward, backward, left, right, shoot);
            }*/
        }

		function draw() {
			const canvas = document.getElementById("canvas");
			if (canvas.getContext) {
				const ctx = canvas.getContext("2d");
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				ctx.strokeRect(1, 1, canvas.width-2, canvas.height-2);

				for (const tank in tanks){
					// first save the untranslated/unrotated context
					ctx.save();
					ctx.beginPath();
					// move the rotation point to the center of the rect
					ctx.translate(tanks[tank].xpos+tanks[tank].width/2, tanks[tank].ypos+tanks[tank].height/2 );

					// rotate the rect
					ctx.rotate(tanks[tank].deg*Math.PI/180);
                    // draw tank turret
					ctx.fillRect(-tanks[tank].width/10, 0, tanks[tank].width/5, -tanks[tank].height);
                    // draw tank body
					ctx.fillRect(-tanks[tank].width/2, -tanks[tank].height/2, tanks[tank].width, tanks[tank].height);
					ctx.restore();
                    ctx.closePath()
                    for(const shot in tanks[tank].shots){
                        ctx.moveTo(tanks[tank].shots[shot].xpos, tanks[tank].shots[shot].ypos);
                        ctx.arc(tanks[tank].shots[shot].xpos, tanks[tank].shots[shot].ypos, tanks[tank].shots[shot].rad, 0, 2 * Math.PI);
                    }
                    ctx.stroke();
				}
			}
		}

		function loop(){
			for(tank in tanks){
				tanks[tank].update_pos();
				draw();
			}
		}

		function start(){
			create_tanks(1);
			setInterval(loop, 20);
		}

        document.addEventListener('keydown', function (event) {
            for (const tank in tanks){
                tanks[tank].check_buttons(event.key, true);
            }
		}, true);

        document.addEventListener('keyup', function (event) {
            for (const tank in tanks){
                tanks[tank].check_buttons(event.key, false);
            }
		}, true);

        window.addEventListener("gamepadconnected", (e) => {
            console.log(
                "Gamepad connected at index %d: %s. %d buttons, %d axes.",
                e.gamepad.index,
                e.gamepad.id,
                e.gamepad.buttons.length,
                e.gamepad.axes.length,
            );
        });


	</script>
</html>