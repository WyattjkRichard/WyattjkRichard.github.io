<!DOCTYPE html>
<html>
	<head>
		<title>Rush Hour</title>
		<link rel="icon" href="../assets/images/icon.png">
		<meta name="robots" content="noindex">
	</head>
	<body>
		<canvas id="canvas" height="300" width="300"></canvas>
	</body>
	<script>
		var drag = false;
		var dragOffset;
		var gridSize = 50;
		var movingShape;
		var movementRange = {
			xMin: 0,
			xMax: canvas.width,
			yMin: 0,
			yMax: canvas.height
		}
		let shapes = {
			red: {
				x: 0,
				y: 0,
				height: gridSize*2,
				width: gridSize,
				colour: "red"
			},
			blue: {
				x: gridSize*2,
				y: gridSize,
				height: gridSize*2,
				width: gridSize,
				colour: "blue"
			},
			green: {
				x: gridSize*4,
				y: gridSize*2,
				height: gridSize,
				width: gridSize*2,
				colour: "green"
			},
			yellow: {
				x: gridSize*3,
				y: gridSize,
				height: gridSize*2,
				width: gridSize,
				colour: "yellow"
			},
		}
		
		draw()
		for (const rect in shapes){
			movingShape = rect;
			snap();
		}
		
		function draw() {
			const canvas = document.getElementById("canvas");
			if (canvas.getContext) {
				const ctx = canvas.getContext("2d");
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				ctx.strokeRect(1, 1, canvas.width-2, canvas.height-2);
				
				if(shapes.red.height>shapes.red.width){ // vertical
					ctx.clearRect(0*gridSize, 0, gridSize, 2);
				}
				else{ // horizontal
					ctx.clearRect(0, 3*gridSize, 2, gridSize);
				}
				
				
				for (let i = 0;i<6;i++){
					for (let j = 0;j<6;j++){
						ctx.strokeRect((gridSize*.1)+i*gridSize, (gridSize*.1)+j*gridSize, (gridSize*.8), (gridSize*.8));
					}
				}
				for (const rect in shapes){
					ctx.fillStyle = shapes[rect].colour;
					ctx.fillRect(shapes[rect].x+2, shapes[rect].y+2, shapes[rect].width-4, shapes[rect].height-4);
				}
			}
		}
		
		function snap(){
			if(shapes[movingShape].x%gridSize<gridSize/2){
				shapes[movingShape].x = Math.floor(shapes[movingShape].x/gridSize)*gridSize
			}
			else{
				shapes[movingShape].x = (Math.floor(shapes[movingShape].x/gridSize)+1)*gridSize
			}
			if(shapes[movingShape].y%gridSize<gridSize/2){
				shapes[movingShape].y = Math.floor(shapes[movingShape].y/gridSize)*gridSize
			}
			else{
				shapes[movingShape].y = (Math.floor(shapes[movingShape].y/gridSize)+1)*gridSize
			}
		}

		function updateDragOffset(){
			dragOffset = {
				x: event.pageX - canvas.offsetLeft - shapes[movingShape].x,
				y: event.pageY - canvas.offsetTop - shapes[movingShape].y
			}
		}
		
		function updateMovementRange(){
			movementRange = {
				xMin: 0,
				xMax: canvas.width,
				yMin: 0,
				yMax: canvas.height
			}
			for (const rect in shapes){
				if(rect!=movingShape){
					if (shapes[movingShape].height>shapes[movingShape].width){ // vertical
						if(shapes[rect].x==shapes[movingShape].x || shapes[rect].x<shapes[movingShape].x && shapes[rect].x+shapes[rect].width>shapes[movingShape].x){
							if(shapes[rect].y<shapes[movingShape].y){
								if(shapes[rect].y+shapes[rect].height>movementRange.yMin){
									movementRange.yMin = shapes[rect].y+shapes[rect].height;
								}
							}
							else if(shapes[rect].y>shapes[movingShape].y){ // below
								if(shapes[rect].y<movementRange.yMax){
									movementRange.yMax = shapes[rect].y;
								}
							}
						}
					}
					else{ // horizontal
						//check for any rectangle that is in the same row, set max and min range of movement
						if(shapes[rect].y==shapes[movingShape].y || shapes[rect].y<shapes[movingShape].y && shapes[rect].y+shapes[rect].height>shapes[movingShape].y){
							if(shapes[rect].x<shapes[movingShape].x){
								console.log('same row - left')
								if(shapes[rect].x+shapes[rect].width>movementRange.xMin){
									movementRange.xMin = shapes[rect].x+shapes[rect].width;
								}
							}
							else{
								if(shapes[rect].x<movementRange.xMax){
									movementRange.xMax = shapes[rect].x;
								}
								console.log('same row - right')
							}
						}
					}
				}
			}
		}
		
		canvas.addEventListener('mousedown', function(event) {
			//console.log('mousedown');
			for (const rect in shapes){
				if(event.pageX - canvas.offsetLeft > shapes[rect].x && event.pageX - canvas.offsetLeft < shapes[rect].x+shapes[rect].width && event.pageY - canvas.offsetTop > shapes[rect].y && event.pageY - canvas.offsetTop < shapes[rect].y+shapes[rect].height){
					//console.log('hovering')
					drag = true;
					movingShape = rect;
					updateDragOffset()
					updateMovementRange()
				}
			}
		})
	
		addEventListener('mousemove', function(event) {
			if (drag) {
				if(shapes[movingShape].height>shapes[movingShape].width){ // vertical
					shapes[movingShape].y = event.pageY - canvas.offsetTop - dragOffset.y
					if(shapes[movingShape].y<movementRange.yMin){
						shapes[movingShape].y = movementRange.yMin
					}
					else if(shapes[movingShape].y>movementRange.yMax-shapes[movingShape].height){
						shapes[movingShape].y = movementRange.yMax-shapes[movingShape].height
					}
				}
				else if(shapes[movingShape].height<shapes[movingShape].width){ // horizontal
					shapes[movingShape].x = event.pageX - canvas.offsetLeft - dragOffset.x
					if(shapes[movingShape].x<movementRange.xMin){
						shapes[movingShape].x = movementRange.xMin
					}
					else if(shapes[movingShape].x>movementRange.xMax-shapes[movingShape].width){
						shapes[movingShape].x = movementRange.xMax-shapes[movingShape].width
					}
				}
				//if block is being moved out of square, dont allow it, update drag offset
				draw();
			}
		})

		addEventListener('mouseup', function(event) {
			drag = false;
			snap();
			draw();
		})
	
	</script>
</html>